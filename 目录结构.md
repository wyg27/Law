## 说明

以下目录结构以 Laravel 9 为基础。

## 目录结构细节

### Controller

- 所有 API 相关的 controller 都应该放在 `app/Http/Controllers/Api` 内。
- 可以根据业务/模块进一步建立子目录，比如 `app/Http/Controllers/Api/Order` 。

### Model

- 所有 model 都应该放在 `app/Models` 内。
- 可以根据业务/模块进一步建立子目录，比如 `app/Models/ActiveCampaign` 。

### Repository

- 所有的 repository 都应该放在 `app/Repositories` 内。
- 可以根据业务/模块进一步建立子目录，比如 `app/Repositories/ApiDemo` 。

这里解释一下什么是“repository”。其实，它叫什么名字并不重要，它的目的是在 model 之上增加一个“层”，用来放置与 model 有关的 CURD 操做，也有可能是比 CURD 稍微复杂一点的，掺杂了少量业务逻辑的操作。多出的这一“层”令我们可以更好的将操纵数据的业务逻辑与数据本身隔离开，而隔离开的好处之一就是让我们的代码可以单元测试。

枯燥的解释不如一个好的例子。先来看一段无法进行单元测试的业务逻辑代码：

```php
<?php

class Coupon {
    public calDiscount(Order $order) {
        return $order->subtotal * (70/100);
    }
}
```
上面的代码很简单，就是传入一个订单的 model 对象，然后计算它减免30%后的价值是多少。但是，因为 `calDiscount()` 限定了传入的参数必须是一个 model，所以我们很难为它编写单元测试。原因是我们在测试中必须依赖数据库连接才能生成一个订单的 model 对象，这意味着测试环境变得复杂了，还要频繁的在数据库中制造“假数据”来满足不同的测试条件。

你可能会说“没事，其实在不连接数据库的情况下我们也可以 new 一个订单的 model 对象出来进行测试”；是的，你说的方法我也知道，我甚至还知道最新的 Laravel 框架允许我们在单元测试中引入数据库连接。可惜，这并不是正确的方式。Laravel 框架提供的功能只是一种面对现实的无奈妥协 —— 程序员们擅于写出高度耦合的业务逻辑，而这样的业务逻辑在单元测试中难以脱离数据库连接。

那么，再来看看增加了 repository 之后的写法：

```php
<?php

class Coupon {
    public calDiscount(OrderRepository $order) {
        return $order->subtotal * (70/100);
    }
}
```

### 其它自定义 Class 或“Helper”
